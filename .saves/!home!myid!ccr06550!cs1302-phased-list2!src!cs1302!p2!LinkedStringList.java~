package cs1302.p2;

import cs1302.adt.StringList;
import cs1302.adt.Node;
import cs1302.p2.BaseStringList;
import cs1302.adt.FancyStringList;

/**
 * LinkedStringList class extends BaseStringList class but also contains helper methods.
 */
public class LinkedStringList extends BaseStringList {

    private Node head;

    /**
     * LinkedStringList is a constructor for the LinkedStringList class.
     */
    public LinkedStringList() {
        super();
    } //constructor

    /**
     * add adds the item to the specified index in the list.
     * @param index is where the item is added to in the list
     * @param item is the string that is being added to the list
     * @return true if this list is changed as a result of call
     */
    @Override // make sure to add exceptions
    public boolean add(int index, String item) throws IndexOutOfBoundsException,
        NullPointerException, IllegalArgumentException {
        if (item == null) {
            throw new NullPointerException("The item is null");
        } else if (item.length() == 0) {
            throw new IllegalArgumentException("The item is empty");
        } else if (index < 0 || index > size()) {
            throw new IndexOutOfBoundsException("Index is out of range.");
        }
        if (isEmpty()) {
            head = new Node(item);
        } else if (index == 0) {
            head = new Node(item, head);
        } else {
            Node tempNode = head;
            for (int i = 1; i < index; i++) {
                tempNode = tempNode.getNext();
            } // for
            tempNode.setNext(new Node(item, tempNode.getNext()));
        } // if
        size++;
        return true;
    } //add

    /**
     * clear removes the everything from the string.
     */
    @Override
    public void clear() {
        head = null;
        size = 0;
    } //clear

    /**
     * get gets the item in the node at the specified index.
     * @param index the location of the specified point in the list
     * @return the item at the specified index position in this string list
     */
    @Override
    public String get(int index) throws IndexOutOfBoundsException {
        Node tempNode = head;
        if (isEmpty()) {
            throw new IndexOutOfBoundsException("The list is empty.");
        } else if (index == 0) {
            return tempNode.getItem();
        } else if (index < 0 || index >= size()) {
            throw new IndexOutOfBoundsException("Index is out of range.");
        } else {
            String tempString;
            for (int i = 0; i < index; i++) {
                tempNode = tempNode.getNext();
            }
            return tempNode.getItem();
        } // else
    } //get

    /**
     * remove removes the item at the specified index in this list.
     * @param index is the specified location of item in this list
     * @return the item removed from the list
     */
    @Override // everything basically needs to be shifted to the left over the index
    public String remove(int index) throws IndexOutOfBoundsException {
        String tempString = "";
        if (index < 0 || index >= size()) {
            throw new IndexOutOfBoundsException("Index is out of range.");
        } else if (isEmpty()) {
            throw new IndexOutOfBoundsException("The list is empty.");
        } else if (index == 0) {
            tempString = head.getItem();
            head = head.getNext();
        } else {
            Node tempNode = head;
            for (int i = 1; i < index; i++) {
                tempNode = tempNode.getNext();
            } // for
            tempString = tempNode.getNext().getItem();
            tempNode.setNext(tempNode.getNext().getNext());
        } // else
        size--;
        return tempString;
    } //remove

    /**
     * slice creates a smaller version of the list splicing in using the parameters start and stop.
     * @param start the left inclusive endpoint of the slice
     * @param stop the right exclusive endpoint of the slice
     * @return returns a new string with the items from start to stop
     */
    @Override
    public StringList slice(int start, int stop) throws IndexOutOfBoundsException {
        StringList slicedList = new LinkedStringList();
        if (start < 0 || stop > size() || start > stop || isEmpty()) {
            throw new IndexOutOfBoundsException("Illegal endpoint index value.");
        } else {
            for (int i = start; i < stop; i++) {
                slicedList.append(get(i));
            } // for
            return slicedList;
        } // else
    } //slice

    /**
     * LinkedStringList is a constructor and makes a deep copy of another string list.
     * @param other another string list is put into the contructor to make a copy of other
     */
    public LinkedStringList(StringList other) {
        super();
        if (other == null) {
            throw new NullPointerException("The list to add cannot be null");
        } // if
        for (int i = 0; i < other.size(); i++) {
            add(i, other.get(i));
        }
    } // constructor

    @Override
    public FancyStringList slice(int start, int stop, int step) throws IndexOutOfBoundsException {
        FancyStringList slicedList = new LinkedStringList();
        if (start < 0 || stop > size() || start > stop || step < 1) {
            throw new IndexOutOfBoundsException("Illegal endpoint index value.");
        } // if
        int counter = 0;
        for ( int i = start; i < stop; i = start + (counter * step)) {
            slicedList.append(get(i));
            counter++;
        } // for
        return slicedList;
    } // slice

    @Override
    public FancyStringList reverse() {
        FancyStringList tempList = new LinkedStringList();
//        Node tempNode = head;
        for ( int i = 0; i < size ; i++) {
            tempList.prepend(get(i));
        } // for
        return tempList;
    } // reverse
} //LinkedStringList
